name: Delete untagged and/or unsupported Docker images on ghcr.io

# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# GitHub Actions Documentation
# https://docs.github.com/en/github-ae@latest/actions

# Reusing workflows
# https://docs.github.com/en/actions/using-workflows/reusing-workflows

on:
  # Run on every 15th day-of-month at 10:15 AM UTC
  # schedule:
  #   - cron: '15 10 */15 * *'
  # on button click
  # https://docs.github.com/en/enterprise-cloud@latest/actions/using-workflows/workflow-syntax-for-github-actions#onworkflow_dispatch
  workflow_dispatch:
    inputs:
      tags:
        description: 'Spare unsupported tags (whitespace-separated)'
        required: false
        type: string
  # or on calling as reusable workflow
  workflow_call:
    inputs:
      tags:
        description: 'Spare unsupported tags (whitespace-separated)'
        required: false
        type: string

env:
  # Use docker.io for Docker Hub if empty
  REGISTRY_HOST: ghcr.io
  # Use github.repository (<account>/<repo>)
  REPOSITORY_NAME: ${{ github.repository }}
  # Use github.repository_owner (<account>)
  OWNER_NAME: ${{ github.repository_owner }}

jobs:
  # Calling a reusable workflow
  setup:
    uses: ./.github/workflows/read-matrix.yml
    with:
      matrix-path: docker/build/matrix.json

  # Ensure that the repository is given Admin access by going on
  # Package settings -> Manage Actions access
  # https://github.com/actions/delete-package-versions/issues/74
  cleanup:
    runs-on: ubuntu-latest
    permissions:
      # can upload and download package, as well as read/write package metadata
      packages: write
    strategy:
      matrix:
        image:
          - boca-base
          # - boca-web
          # - boca-jail
    needs: setup

    steps:
      # Setting output parameters between steps, jobs and/or workflows
      # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#setting-an-output-parameter
      - 
        name: Write package_name variable to GITHUB_ENV
        id: setup
        run: |

          OWNER='${{ env.OWNER_NAME }}'
          REPO='${{ env.REPOSITORY_NAME }}'
          # Remove owner from repository name
          PACKAGE=${REPO//$OWNER\//}
          echo $PACKAGE
          echo "package_name=${PACKAGE}" >> $GITHUB_OUTPUT

      # Set up GitHub Actions workflow with a specific version of Go
      # https://github.com/marketplace/actions/setup-go-environment
      - 
        uses: actions/setup-go@v4
        with:
          go-version: 1.15

      # Install and setup crane
      # https://github.com/imjasonh/setup-crane
      - 
        uses: imjasonh/setup-crane@v0.3

      # Necessary if testing locally with 'act'
      # https://github.com/nektos/act

      # Install GH CLI (self-hosted runners do not come with it out of the box)
      # https://github.com/dev-hanz-ops/install-gh-cli-action
      # - 
      #   name: Install GH CLI
      #   uses: dev-hanz-ops/install-gh-cli-action@v0.1.0
      #   with:
      #     gh-cli-version: 2.14.2 # optional, see action.yml for current default

      - 
        name: Compile unsupported versions/releases to delete
        id: unsupported
        run: |

          # Get supported releases
          RELEASES=${{ toJSON(needs.setup.outputs.release) }}
          # Remove square brackets and double quotes
          RELEASES=$(echo $RELEASES | tr -d "[]|\"")
          # Split string into an array
          IFS=', ' read -r -a RELEASES <<< "$RELEASES"
          # Include custom tags provided as argument
          echo "${{ inputs.tags }}"
          if [ ! -z "${{ inputs.tags }}" ];
          then
            read -a TAGS <<< "${{ inputs.tags }}"
            for tag in ${TAGS[@]};
            do
              echo "${tag}"
              RELEASES+=("$tag")
            done
          fi
          echo "${RELEASES[@]}"

          # Set image
          IMG=${{ env.REGISTRY_HOST }}/${{ env.REPOSITORY_NAME }}/${{ matrix.image }}

          # Get all releases/tags
          ALLRELEASES=$(crane ls ${IMG} || echo "")
          # If list of tags is empty just skip it
          if [ -z "${ALLRELEASES}" ];
          then
            exit 0
          fi

          # Remove newlines, tabs, carriage returns and double quotes
          ALLRELEASES=$(echo $ALLRELEASES | tr -d "\n\t\r|\"")
          # Split string into an array
          IFS=', ' read -r -a ALLRELEASES <<< "$ALLRELEASES"
          echo "${ALLRELEASES[@]}"

          # Get unsupported releases
          DEPRECATED=()
          for i in "${ALLRELEASES[@]}";
          do
            skip=
            for j in "${RELEASES[@]}";
            do
              [[ $i == $j ]] && { skip=1; break; }
            done
            [[ -n $skip ]] || DEPRECATED+=("$i")
          done
          declare -p DEPRECATED
          echo "${DEPRECATED[@]}"

          PACKAGE=${{ steps.setup.outputs.package_name }}
          ENCODED_PACKAGE="${PACKAGE}/${{ matrix.image }}"
          # Replace '/' with '%2F'
          ENCODED_PACKAGE="${ENCODED_PACKAGE//\//\%2F}"
          echo $ENCODED_PACKAGE

          PACKAGESJSON=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            /users/${{ env.OWNER_NAME }}/packages/container/${ENCODED_PACKAGE}/versions || echo "")
          echo $PACKAGESJSON

          # If list of package versions does not exist just fail
          if [ -z "${PACKAGESJSON}" ];
          then
            exit 1
          fi

          # Unset variable
          unset VERSIONIDS

          # Iterate over releases to get digests
          for version in ${DEPRECATED[@]};
          do
            echo "${version}"

            # Only proceed in case an unsupported version does not coexit
            # with a supported one
            CURR_VERSIONS=`echo $PACKAGESJSON | \
                jq --arg var $version \
                  '.[] | select(any(.metadata.container.tags[]; . == $var)) | .metadata.container.tags'`
            # Remove newlines, tabs, carriage returns and double quotes
            CURR_VERSIONS=$(echo $CURR_VERSIONS | tr -d "\n\t\r|\"")
            # Split string into an array
            IFS=', ' read -r -a CURR_VERSIONS <<< "$CURR_VERSIONS"
            echo "${CURR_VERSIONS[@]}"

            unset SHARED
            for curr in ${CURR_VERSIONS[@]};
            do
              if [[ " ${RELEASES[*]} " =~ " ${curr} " ]];
              then
                SHARED=true
                echo "WoW"
                break
              fi
            done

            if [ ! -z "${SHARED}" ];
            then
              echo "Skipping ${version} (conflicting)"
              continue
            fi

            VERSIONIDS="${VERSIONIDS} \
              `echo $PACKAGESJSON | \
                jq --arg var $version \
                  '.[] | select(any(.metadata.container.tags[]; . == $var)) | .id'`"
          done

          # Remove newlines, tabs, carriage returns and double quotes
          VERSIONIDS=$(echo ${VERSIONIDS} | tr -d "\n\t\r|\"")
          # Replace white spaces with ', '
          VERSIONIDS="${VERSIONIDS// /, }"
          # Split string into an array
          IFS=', ' read -r -a VERSIONIDS <<< "$VERSIONIDS"
          echo "${VERSIONIDS[@]}"

          # Keep unique version ids only
          UNIQIDS=($(printf "%s\n" "${VERSIONIDS[@]}" | sort -u))
          echo "${UNIQIDS[@]}"

          # Convert to string
          UNIQSTR=$(echo $(IFS=, ; echo "${UNIQIDS[*]}"))
          # Add white space after ','
          UNIQSTR="${UNIQSTR//,/, }"
          echo $UNIQSTR
          # Passing env variable between steps
          echo "version_ids=${UNIQSTR}" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Delete package versions
      # https://github.com/actions/delete-package-versions
      - 
        name: Delete multiple specific Docker images on ghcr.io
        uses: actions/delete-package-versions@v4
        if: ${{ steps.unsupported.outputs.version_ids != '' }}
        with:
          package-version-ids: '${{ steps.unsupported.outputs.version_ids }}'
          package-name: '${{ steps.setup.outputs.package_name }}/${{ matrix.image }}'
          package-type: 'container'
          token: ${{ secrets.GITHUB_TOKEN }}

      # - 
      #   name: Compile untagged versions/releases to ignore
      #   id: untagged
      #   run: |

      #     # Get supported releases
      #     RELEASES=${{ toJSON(needs.setup.outputs.release) }}
      #     # Remove square brackets and double quotes
      #     RELEASES=$(echo $RELEASES | tr -d "[]|\"")
      #     # Split string into an array
      #     IFS=', ' read -r -a RELEASES <<< "$RELEASES"
      #     # Include custom tags provided as argument
      #     echo "${{ inputs.tags }}"
      #     if [ ! -z "${{ inputs.tags }}" ];
      #     then
      #       read -a TAGS <<< "${{ inputs.tags }}"
      #       for tag in ${TAGS[@]};
      #       do
      #         echo "${tag}"
      #         RELEASES+=("$tag")
      #       done
      #     fi
      #     echo "${RELEASES[@]}"

      #     # Unset variable
      #     unset DIGESTKEYS
      #     # Set image
      #     IMG=${{ env.REGISTRY_HOST }}/${{ env.REPOSITORY_NAME }}/${{ matrix.image }}

      #     # Iterate over releases to get digests
      #     for version in ${RELEASES[@]};
      #     do
      #       echo "${version}"

      #       # If manifest does not exist just skip image
      #       MANIFEST=$(crane manifest ${IMG}:${version} || echo "")
      #       if [ -z "${MANIFEST}" ];
      #       then
      #         continue
      #       fi

      #       # Get digest key(s) of regular image (if not multi-arch)
      #       DIGESTKEYS="${DIGESTKEYS} \
      #         `crane manifest ${IMG}:${version} | \
      #           jq 'select (.config != null) | .config.digest'`"
      #       # or of multi-platform images builds
      #       DIGESTKEYS="${DIGESTKEYS} \
      #         `crane manifest ${IMG}:${version} | \
      #           jq 'select (.manifests != null) | .manifests[].digest'`"
      #     done

      #     # Remove newlines, tabs, carriage returns and double quotes
      #     DIGESTKEYS=$(echo $DIGESTKEYS | tr -d "\n\t\r|\"")
      #     # Replace white spaces with '|'
      #     DIGESTKEYS="${DIGESTKEYS// /|}"
      #     echo $DIGESTKEYS

      #     # Passing env variable between steps
      #     echo "digest_keys=${DIGESTKEYS}" >> $GITHUB_OUTPUTS

      # - 
      #   name: Delete untagged Docker images on ghcr.io
      #   uses: actions/delete-package-versions@v4
      #   if: ${{ steps.untagged.outputs.digest_keys != '' }}
      #   with:
      #     package-name: '${{ steps.setup.outputs.package_name }}/${{ matrix.image }}'
      #     package-type: 'container'
      #     delete-only-untagged-versions: 'true'
      #     ignore-versions: '${{ steps.untagged.outputs.digest_keys }}'
      #     token: ${{ secrets.GITHUB_TOKEN }}
